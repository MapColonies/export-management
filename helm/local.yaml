global:
  cloudProvider:
    dockerRegistryUrl: acrarolibotnonprod.azurecr.io
    imagePullSecretName: 'acr-registry'
    flavor: openshift
  tracing: {}
  metrics: {}
  environment: {}
  servicePort: 8080


enabled: true
environment: development
replicaCount: 1
initialDelaySeconds: 60
nodePort: 30030 #for minikube deployment only
resetOnConfigChange: true
imagePullPolicy: Always

caSecretName: ''
caPath: '/usr/local/share/ca-certificates'
caKey: 'ca.crt'

image:
  repository: export-management
  tag: 'v1.1.4'

serviceUrls:
  exporterTrigger: "http://exporter-trigger-raster-dev-exporter-trigger/"
  jobManager: "http://common-job-manager-raster-dev-job-manager/"
jobManagement:
  exporter:
    jobType: rasterTilesExporter
authentication:
  opa:
    enabled: true
    customHeaderName: "x-api-key"


env:
  port: 8080
  internalPort: 80
  targetPort: 8080
  protocol: TCP
  logLevel: info
  logPrettyPrintEnabled: false
  responseCompressionEnabled: true
  requestPayloadLimit: 1mb
  disableHttpClientLogs: false
  #https://exoprt-management-no-auth-integration.apps.j1lk3njp.eastus.aroapp.io/export-tasks/webhook
  serviceWebhookEndpoint: http://export-management-export-management/export-tasks/webhook
  tracing:
    enabled: false
    url: http://localhost:55681/v1/trace
  metrics:
    enabled: false
    url: http://localhost:55681/v1/metrics
  httpRetry:
    attempts: 5
    delay: exponential
    shouldResetTimeout: true
  
resources:
  enabled: true
  value:
    limits:
      cpu: 100m
      memory: 128Mi
    requests:
      cpu: 100m
      memory: 128Mi
  port: 8080
  internalServicePort: 80
  targetPort: 8080
  servicePort: 8080
  nodePort: 30001
nginx:
  enabled: true
  replicaCount: 2
  image:
    repository: nginx-otel-unprivileged
    tag: 'v1.0.0' 
  port: 8080
  internalServicePort: 80
  targetPort: 8080
  servicePort: 8080
  nodePort: 30001
  authorization:
    enabled: true
    domain: 'raster'
    url: http://opa-la-opa-service.integration/v1/data/http/authz/decision

  defaultConf: |-
    {{- $chartName := include "export-management.name" . -}}
    {{- $serviceName := include "export-management.fullname" . -}}
    {{- $releaseName := .Release.Name -}}

    map $msec $nanosec {
        "~*(\d{10})\.(\d{3})" "$1$2000000";
    }

    upstream export-management {
        server {{ $serviceName }}:{{ .Values.global.servicePort  }};
    }

    server {
        listen      {{ .Values.targetPort }};
        # the domain name it will serve for
        server_name export-management;
        # max upload size, adjust to taste
        keepalive_timeout  500;
        proxy_connect_timeout       600;
        proxy_send_timeout          600;
        send_timeout                600;
        client_max_body_size        5000;
        client_header_timeout       600;
        client_body_timeout         600;
        client_header_buffer_size   12288; # 12K
        large_client_header_buffers 4 12288; # 12K
        fastcgi_read_timeout        300;
        location /liveness {
            return 200 "I'm alive\n";
        }
        location / {
            set $original_method $request_method;
            set $original_args $args;

            {{ if .Values.authorization.enabled }}
            set $domain {{ .Values.authorization.domain }};
            auth_request /_validate_jwt;
            {{ end }}

        }

            {{ if .Values.authorization.enabled }}
            location = /_validate_jwt {
              internal;

              js_content auth.opaAuth;
            }

            location = /opa {
              internal;

              proxy_set_header Content-Type application/json;
              proxy_pass {{ .Values.authorization.url }};
            }    
            {{ end }}

    }

  nginxConf: |-
    #user  nginx;
    load_module /otel/otel_ngx_module.so;
    load_module modules/ngx_http_js_module.so;  
    worker_processes  4;

    error_log  /var/log/nginx/error.log notice;
    pid        /tmp/nginx.pid;

    events {
        worker_connections  1024;
    }


    http {
        include       /etc/nginx/mime.types;
        default_type  application/octet-stream;
        opentelemetry_config /otel/otel-nginx.toml;

        {{ if .Values.authorization.enabled }}
        js_import auth from /etc/nginx/auth.js;
        js_set $jwt_payload_sub auth.jwtPayloadSub;
        {{ end }}
        

        log_format json escape=json 
        '{'
            '"Timestamp": $nanosec,'
            '"Attributes": {'
                '"time_local": "$time_local",'
                '"http.status_code": $status,'
                '"http.url": "$http_referer",'
                '"http.x_forwarded_for": "$http_x_forwarded_for",'
                '"http.user_agent": "$http_user_agent",'
                '"http.request_time": $request_time,'
                '"request_length": "$request_length",'
                '"http.host": "$host",'
                '"upstream_response_time": $upstream_response_time,'
                '"body_bytes_sent": "$body_bytes_sent",'
                '"remote_addr": "$remote_addr",'
                '"remote_user": "$remote_user",'
                '"connection":"$connection",'
                '"connection_requests": "$connection_requests",'
                '"connections_active": "$connections_active",'
                '"connections_reading": "$connections_reading",'
                '"connections_writing": "$connections_writing",'
                '"connections_waiting": "$connections_waiting"'
            '},'
            #'"TraceId": "$opentelemetry_trace_id",' ## this is a byte sequence (hex-encoded in JSON)
            #'"SpanId": "$opentelemetry_span_id",'
            '"TokenUser": "$jwt_payload_sub",'
            '"SeverityText": "INFO",'
            '"SeverityNumber": 9,'
            '"RequestBody": "$request_body",'
            '"Body": "$request"'
        '}';

        access_log  /var/log/nginx/access.log json;

        sendfile        on;
        #tcp_nopush     on;

        keepalive_timeout  65;

        #gzip  on;

        include /etc/nginx/conf.d/*.conf;
    }